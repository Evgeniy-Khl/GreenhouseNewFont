/*******************************************************
Project : Greenhouse
Version : 0.0
Date    : 07.10.2022
Clock   : 16 MHz
Program size: 15336 words (30672 bytes), 93,6% of FLASH  26.10.2022
*******************************************************/

#include <mega32.h>
#include <stdio.h>
#include <twi.h>
#include <delay.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <1wire.h>
#include "fontsN.h"
#include "tft.h"
#include "9341.h"
//*********************************
#define CSDAC1		    PORTD.4
#define CSDAC2		    PORTD.5
#define CSDAC3		    PORTD.6
#define CSDAC4	        PORTD.7
#define CONECT          PINB.3    // если bluetooth подключен то здесь +3,3В
#define MAX_DEVICES     2
#define MAX_MENU        6
#define MAX_4           4
#define MAX_5           5
#define MAX_6           6
#define MAX_7           7
#define MISTAKE         3
#define ZERO	        50

#define DATAREAD        0xA1    // Read Scratchpad
#define EEPROMREAD      0xB1    // Read EEPROM
#define DS3231          0xD0    // Часовая микросхема

#define SPI_MOUD_FL	    0x51	  // SPI Type: Master, Clock Rate: 1000,000 kHz, Clock Phase: Cycle Half, Clock Polarity: Low, Data Order: MSB First
#define TWI_CLK_RATE    100000    // TWI clock rate [bps]
#define EEPROM_TWI_BUS_ADDRESS (0xA0 >> 1)// 7 bit TWI bus slave address of the AT24C16B 2kbyte EEPROM
#define ADC_VREF_TYPE   0x40

// Declare your global variables here
unsigned char BeepT, displ_num, ok, portOut, newSetButt, ds18b20, soilModule, pointY, DHTexist, signchar, intval, frcval, error;
signed char numMenu, numSet, pauseEdit/*, displCO2, timerCO2*/;
unsigned char relOut[4]={0}, analogOut[4]={0}, dacU[4]={ZERO}, buff[40], familycode[MAX_DEVICES][9], clock_buffer[7], alarm[4]={2,2,2,2};
unsigned int  max_X, max_Y, timerOn, timerOff, fillScreen = BLACK;
signed int pvT=1990, offsetT, pvRH=1990, offsetRH, pvCO2, pvPH, newval[MAX_7], t[MAX_DEVICES], hum[MAX_DEVICES];
unsigned char *ptr_char;
const char* setMenu[MAX_MENU]={"Температура","Вологысть","Таймер","День Ныч","Час Дата","Ынше"};
const char* setName0[MAX_7]={"ДЕНЬ","НЫЧ","Выдхил.","Гыстер.","Режим","Резерв","Вихыд"};
const char* setName1[MAX_6]={"Включено","Розмір.","Вимкнено","Розмір.","Крок","ЗМЫЩЕННЯ"};
const char* setName2[MAX_6]={"День почат.","Ныч почат.","Включено Р","Вимкнено Р","Включено В","Вимкнено В"};
const char* setName3[MAX_4]={"MIN","MAX","Пропор.","Ынтегр."};
const char* setName7[MAX_5]={"Хвилини","Години","День","Мысяц","Рык"};
//--------------- union declaration -----------------------------------------------
union {unsigned char buffer[8]; unsigned int pvT;} ds;          // буффер микросхемы DS18B20
union {unsigned char buffer[4]; unsigned int val[2];} in;
union {unsigned char buffer[4]; unsigned int val[2];} out;
//---------------------------------------------------------------------------------
float Told1[5], Told2[5], iPart[4];

//-------------------------
eeprom signed char relaySet[4]={2,2,2,2};
eeprom signed char analogSet[4]={-1,-1,-1,-1};

eeprom signed int set[6][7]={
{ 230, 200,  50,  10,   1,  -1,   0},  // (ВОЗД.) Tday;  Tnight;  dTalarm;  hysteresis;  mode=1(нагрев)/mode=0(охлаждение); резерв;    выход № РЕЛЕ1
{  60,  60,  10,   5,   0,   0,   1},  // (ВОЗД.) RHday; RHnight; dRHalarm; hysteresis;  mode=1(увлажнение)/mode=0(осушение); DHT22=0; выход № РЕЛЕ2
{ 200, 180,  50,  10,   1,  -1,   6},  // (ГРУНТ) Tday;  Tnight;  dTalarm;  hysteresis;  mode=1(нагрев)/mode=0(охлаждение); резерв;    выход №
{ 400, 350, 100,  50,   1,  -1,   7},  // (ГРУНТ) RHday; RHnight;  dTalarm;  hysteresis; mode=1(увлажнение)/mode=0(осушение); резерв;  выход №   
{  10,  0,   10,   1,   0,0x06,   2},  // tmOn; dimOn=0(сек.)/dim=1(мин.); tmOff; dimOff; HourStart; Programm;                         выход № РЕЛЕ3
{0x07,0x20,0x05,0x09,0x18,0x23,   3}}; // DayBeg; DayEnd; Light0Beg; Light0End; Light1Beg; Light1End;                                  выход № РЕЛЕ4

eeprom unsigned int limit[6][4]={
                    // min max  kP   kI 
                      {  0,100, 20, 100}, // 4
                      {  0,100, 20, 100}, // 5
                      {  0,100, 20, 100}, // 6
                      {  0,100, 20, 100}, // 7
                      {  0, 33,270, 530}, // Грунт температура  t=0 -> V=1.32 -> ADC=270; t=25 -> V=2.51 -> ADC=514
                      {  0,100,600, 700}};// Грунт влажность  RH=100% -> V=2.45 -> ADC=435; RH=0% -> V=4.43 -> ADC=920 

bit Night;
bit Sec;
bit Dht;
bit Clock_Ok;
bit pHsensor;
bit CO2module;       // подключен измеритель СО2
bit typeS;           // DHT11/DHT22

//- prototypes ------
void display(void);

#include "fontsN.c"
#include "ili9341.c"
#include "twi.c"
#include "dht.c"
#include "buttons.c"
#include "proc.c"
#include "control.c"
#include "touchpad.c"
#include "displ.c"

// External Interrupt 0 service routine
interrupt [EXT_INT0] void ext_int0_isr(void){
 static unsigned int count1;
 count1++;
}
// 0.25 Hz timer interrupt generated by Timer1 overflow;  Timer Period: 1,0486 s
interrupt [TIM1_OVF] void timer_comp_isr(void){
 Sec=1;
} 


void main(void){
// Declare your local variables here
signed char x, byte;
#include "init.c"

while (1){
//--------------------------- функция 1 секунда ---------------------------------------------
    if(Sec){                     
        Sec=0;
        if(clock_buffer[2]>=set[5][0]&&clock_buffer[2]<set[5][1]) byte=0; else byte=1;
        if(byte!=Night){Night = byte; ok = 0;}      // день / ночь
    // -- работа таймера ----------    
        byte = set[4][4];                           // режим таймера если 0 то простой если 1-14 то программный
        if(byte==0) timerCheck();                   // простой таймер
        else timerRTC(byte);                        // таймер по программе
    // -- работа освещения --------    
        if(clock_buffer[2]>=set[5][2]&&clock_buffer[2]<set[5][3]) x=1; else x=0; // Light0Beg; Light0End;
        if(x==0){if(clock_buffer[2]>=set[5][4]&&clock_buffer[2]<set[5][5]) x=2; else x=0;}//Light1Beg; Light1End;
        byte = set[5][6];  // № выхода таймера
        if(x>0){
            relOut[byte] = 1;
            byte = 1 << byte;
            portOut |= byte;
            if(x==1) byte = rtcTodec(set[5][3])-1; else byte = rtcTodec(set[5][5])-1;            
            sprintf(txt,"ON  вимкн.%02u:59:59",byte);
        } 
        else {
            relOut[byte] = 0;
            byte = 1 << byte;
            portOut &= ~byte;
            if(Night) byte = rtcTodec(set[5][2]); else byte = rtcTodec(set[5][4]);
            sprintf(txt,"OFF включ.%02u:00:00",byte);
        }
    // -- измерение параметров воздуха ---------            
        if(Dht){                                         // присутствует датчик влажности
            if(readDHT()) DHTexist = 3; 
            else if(DHTexist) DHTexist--;                // датчик влажности работает? 
            else {pvT = 1900; pvRH = 190;}
        }
    // -- измерение параметров грунта ---------
        if(ds18b20) temperature_check();
        else if(soilModule) soilModule_check(DATAREAD); 
        // --------КАНАЛ температура воздуха ВЫХОД 0 и ВЫХОД 4 ---------
         if(Dht){RelaySensor(pvT,0); analogOut[0]=UpdatePI(pvT,0);}
         else if(ds18b20){
            RelaySensor((t[0]+t[1])/2,0);  // средняя грунта
            analogOut[0]=UpdatePI((t[0]+t[1])/2,0);
         }
        // --------КАНАЛ влажность воздуха ВЫХОД 1 и ВЫХОД 5 --------- 
        if(Dht){RelaySensor(pvRH,1); analogOut[1]=UpdatePI(pvRH,1);}
        // --------КАНАЛ температура грунта ВЫХОД 6 ---------
        if(ds18b20) analogOut[2]=UpdatePI((t[0]+t[1])/2,2);  // средняя грунта
        // --------КАНАЛ влажность грунта ВЫХОД 7 ---------
        //if(ds18b20) analogOut[3] = UpdatePI((t.point[0]+t.point[1])/2,3);  // средняя грунта
// ================ Управление исполнительными механизмами ======================================
        for(byte=0; byte<4; byte++){
            if(relaySet[byte]<2) relOut[byte]=relaySet[byte];
            if(analogSet[byte]>=0) analogOut[byte] = analogSet[byte]; 
            else analogOut[byte] = limitationOut(analogOut[byte], byte);            
            dacU[byte] = adapt(analogOut[byte]);// конверсия для ЦАП
        }
//        setDAC();                           // подать напряжение на аналоговые выходы
    }
//------------------------- КОНЕЦ функция 1 секунда ---------------------------------------------
    display();
//sprintf(buff,"X%4u; Y%4u; D%u newB=%3u",point_X,point_Y, displ_num, newButton);
//ILI9341_WriteString(5,TFTBUTTON-10,buff,Font_11x18,WHITE,BLACK,1);
 }
}
