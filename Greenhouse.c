/*******************************************************
Project : Greenhouse
Version : 0.0
Date    : 07.10.2022
Clock   : 16 MHz
Program size: 11128 words (22256 bytes), 67,9% of FLASH  14.10.2022
*******************************************************/

#include <mega32.h>
#include <stdio.h>
#include <twi.h>
#include <delay.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <1wire.h>
#include "fontsN.h"
#include "tft.h"
#include "9341.h"
//*********************************
#define CSDAC1		    PORTD.4
#define CSDAC2		    PORTD.5
#define CSDAC3		    PORTD.6
#define CSDAC4	        PORTD.7
#define CONECT          PINB.3    // если bluetooth подключен то здесь +3,3В
#define MAX_DEVICES     3
#define MAX_MENU        5
#define MAX_SET         4
#define MAX_DATE        5
#define MISTAKE         3
#define ZERO	        50

#define SBLK		    0x91      // Начало блока данных
#define BSTR		    0x81      // Начало строки данных
#define EBLK            0xF1      // Конец блока данных
#define DS3231          0xD0      // Часовая микросхема

#define SPI_MOUD_FL	    0x51	  // SPI Type: Master, Clock Rate: 1000,000 kHz, Clock Phase: Cycle Half, Clock Polarity: Low, Data Order: MSB First
#define TWI_CLK_RATE    100000    // TWI clock rate [bps]
#define EEPROM_TWI_BUS_ADDRESS (0xA0 >> 1)// 7 bit TWI bus slave address of the AT24C16B 2kbyte EEPROM
#define ADC_VREF_TYPE   0x40

// Declare your global variables here
unsigned char BeepT, displ_num, ok, portOut, newSetButt, ds18b20, pointY, DHTexist, signchar, intval, frcval, error;
signed char numMenu, numSet/*, displCO2, timerCO2*/;
unsigned char relOut[4]={0}, analogOut[4]={0}, dacU[4]={ZERO}, buff[40], familycode[MAX_DEVICES][9], clock_buffer[7], alarm[4]={2,2,2,2};
unsigned int  max_X, max_Y, timerOn, timerOff, fillScreen = BLACK;
signed int pvT=1990, offsetT, pvRH=1990, offsetRH, pvCO2, pvPH, newval[MAX_DATE];
unsigned char *ptr_char;
const char* setMenu[MAX_MENU]={"Температура","Влажность","Таймер","Настройки","Время и Дата"};
const char* setName0[MAX_SET]={"Задание","Отклон.","Гистер.","Режим"};
const char* setName1[MAX_SET]={"Включен","Выключен", "Размерн.","Шаг"};
const char* setName2[MAX_SET]={"Корекция Т","Корекция Вл","Датчик Вл","Резерв"};
const char* setName3[MAX_DATE]={"минуты","часы","день","месяц","год"};
//--------------- union declaration -----------------------------------------------
union {signed int point[MAX_DEVICES]; unsigned char buff[];} t; // буффер значений температур
union {unsigned char buffer[8]; unsigned int pvT;} ds;          // буффер микросхемы DS18B20
union {unsigned char buffer[4]; unsigned int val[2];} in;
union {unsigned char buffer[4]; unsigned int val[2];} out;
//---------------------------------------------------------------------------------
signed int iPart[4];
float Told1[5], Told2[5];

//-------------------------
eeprom signed char relaySet[4]={2,2,2,2};
eeprom signed char analogSet[4]={-1,30,90,-1};

eeprom signed int set[6][7]={
{ 270, 200,  50,  10,   0,   0,   0},  // (ВОЗД.) Tday;  Tnight;  dTalarm;  hysteresis;  mode=1(нагрев)/mode=0(охлаждение); резерв;    выход № РЕЛЕ1
{  55,  50,  10,   5,   0,   0,   1},  // (ВОЗД.) RHday; RHnight; dRHalarm; hysteresis;  mode=1(увлажнение)/mode=0(осушение); DHT22=0; выход № РЕЛЕ2
{ 200, 180,  50,  10,   0,   0,   4},  // (ГРУНТ) Tday;  Tnight;  dTalarm;  hysteresis;  mode=1(нагрев)/mode=0(охлаждение); резерв;    выход №
{ 400, 350, 100,  50,   0,   0,   5},  // (ГРУНТ) RHday; RHnight;  dTalarm;  hysteresis; mode=1(увлажнение)/mode=0(осушение); резерв;  выход №   
{  10,  10,   1,   0,0x07,   0,   2},  // tmOn; tmOff; dim=0(сек.)/dim=1(мин.)/dim=2(час.); dim; HourStart; Programm;                  выход № РЕЛЕ3
{0x07,0x20,0x05,0x09,0x18,0x23,   3}}; // DayBeg; DayEnd; Light0Beg; Light0End; Light1Beg; Light1End;                                  выход № РЕЛЕ4

eeprom unsigned char limit[4][3]={
                    // max  kP   kI 
                      {100, 20, 200}, // 4
                      {100, 20, 200}, // 5
                      {100, 20, 200}, // 6
                      {100, 20, 200}};// 7 

bit Night;
bit Sec;
bit Dht;
bit Clock_Ok;
bit pHsensor;
bit Soilmodule;
bit CO2module;       // подключен измеритель СО2
bit typeS;           // DHT11/DHT22

//- prototypes ------


#include "fontsN.c"
#include "ili9341.c"
#include "twi.c"
#include "dht.c"
#include "buttons.c"
#include "proc.c"
#include "control.c"
#include "touchpad.c"
#include "displ.c"

// External Interrupt 0 service routine
interrupt [EXT_INT0] void ext_int0_isr(void){
 static unsigned int count1;
 count1++;
}
// 0.25 Hz timer interrupt generated by Timer1 overflow;  Timer Period: 1,0486 s
interrupt [TIM1_OVF] void timer_comp_isr(void){
 Sec=1;
} 


void main(void){
// Declare your local variables here
signed char x, byte;
#include "init.c"

while (1){
   //----------- функция 1 секунда ---------------------------
    if(Sec){                     
        Sec=0;
        if(clock_buffer[2]>=set[5][0]&&clock_buffer[2]<set[5][1]) byte=0; else byte=1;
        if(byte!=Night){Night = byte; ok = 0;}      // день / ночь
        
        byte = set[4][5];
        if(byte==0) timerCheck();                   // простой таймер
        else timerRTC(byte);                        // таймер по программе
        
        if(clock_buffer[2]>=set[5][2]&&clock_buffer[2]<set[5][3]) x=1; else x=-1; // Light0Beg; Light0End;
        if(x==0){if(clock_buffer[2]>=set[5][4]&&clock_buffer[2]<set[5][5]) x=2; else x=-2;}//Light1Beg; Light1End;
        byte = set[5][6];  // № выхода таймера
        if(x>0){
            relOut[byte] = 1;
            byte = 1 << byte;
            portOut |= byte;
            if(x==1) byte = rtcTodec(set[5][3])-1; else byte = rtcTodec(set[5][5])-1;            
            sprintf(txt,"ON  выдкл.%02u:59:59",byte);
        } 
        else {
            relOut[byte] = 0;
            byte = 1 << byte;
            portOut &= ~byte;
            if(x==-1) byte = rtcTodec(set[5][2]); else byte = rtcTodec(set[5][4])-1;
            sprintf(txt,"OFF включ.%02u:00:00",byte);
        }
        
        if(ds18b20) temperature_check();
        if(Dht){                                         // присутствует датчик влажности
            if(readDHT()) DHTexist = 3; 
            else if(DHTexist) DHTexist--;                   // датчик влажности работает? 
            else {pvT = 1900; pvRH = 190;}
        }
        for(byte=0; byte<4; byte++){if(relaySet[byte]<2) relOut[byte]=relaySet[byte];}
        for(byte=0; byte<4; byte++){
            if(analogSet[byte]>=0) analogOut[byte] = analogSet[byte]; else analogOut[byte] = 0; //??????????????
            dacU[byte] = adapt(analogOut[byte]);// конверсия для ЦАП
        }
        //    setDAC();                           // подать напряжение на аналоговые выходы
        // --------КАНАЛ температура воздуха ---------
        byte = set[0][6];  // номер выхода
        if(byte<4){
         if(Dht) RelaySensor(pvT,0);
         else if(ds18b20) RelaySensor((t.point[0]+t.point[1])/2,3);  // средняя грунта
        }
        else {
         if(Dht) analogOut[byte-4] = UpdatePI(pvT,0);
         else if(ds18b20) analogOut[byte-4] = UpdatePI((t.point[0]+t.point[1])/2,3);  // средняя грунта
        }
        // --------КАНАЛ влажность воздуха --------- 
        byte = set[1][6];  // номер выхода
        if(byte<4) if(Dht) RelaySensor(pvRH,1);
        else if(Dht) analogOut[byte-4] = UpdatePI(pvRH,1);
        // --------КАНАЛ температура грунта ---------
        byte = set[2][6];  // номер выхода
        if(byte<4){
         if(Dht && ds18b20) RelaySensor((t.point[0]+t.point[1])/2,3);  // средняя грунта
        }
        else {
         if(Dht && ds18b20) analogOut[byte-4] = UpdatePI((t.point[0]+t.point[1])/2,3);  // средняя грунта
        }
    }
   //---------- функция 1 секунда --------------------------
//   if(newButton==100) display();
//   else {touchpad(newButton); newButton=100; display();}
    display();
//   sprintf(buff,"X%4u; Y%4u; D%u newB=%3u",point_X,point_Y, displ_num, newButton);
//   ILI9341_WriteString(5,TFTBUTTON-10,buff,Font_11x18,WHITE,BLACK,1);
 }
}
